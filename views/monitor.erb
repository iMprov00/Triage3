<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Монитор Триажа — ТВ</title>
  <style>
    /* Встроенные базовые стили для гарантии работы */
    body { margin: 0; padding: 0; font-family: sans-serif; }
    .hidden { display: none !important; }
  </style>
  <link rel="stylesheet" href="/css/monitor.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
</head>
<body>
  <!-- ШАПКА -->
  <header class="monitor-header">
    <div class="monitor-title">
      <h1><i class="bi bi-hospital"></i> ТРИАЖ — МОНИТОР</h1>
    </div>
    
    <div class="monitor-meta">
      <div class="meta-item">
        <span class="label">Время:</span>
        <span class="value time" id="current-time">--:--:--</span>
      </div>
      <div class="meta-item">
        <span class="label">Пациентов:</span>
        <span class="value" id="patients-count">0</span>
      </div>
    </div>
  </header>


  <!-- ОСНОВНОЙ КОНТЕНТ -->
  <main>
    <div id="patients-container" class="patients-container">
      <!-- Карточки пациентов будут вставляться здесь через JavaScript -->
    </div>

    <!-- СООБЩЕНИЕ ЕСЛИ НЕТ ПАЦИЕНТОВ -->
    <div id="no-patients" class="no-patients hidden">
      <h3><i class="bi bi-people"></i> Нет активных пациентов</h3>
      <p>Ожидание поступления новых пациентов...</p>
    </div>
  </main>

  <!-- ШАБЛОН КАРТОЧКИ ПАЦИЕНТА (ЭТАПЫ ТРИАЖА) -->
  <template id="patient-card-template">
    <div class="patient-card" data-id="">
      <div class="card-top">
        <div class="patient-main">
          <h2 class="patient-name"></h2>
          <div class="patient-meta">
            <span class="performer"></span> • <span class="admission-time"></span>
          </div>
        </div>
        <span class="step-badge"></span>
      </div>
      
      <div class="timer-block">
        <div class="timer-display normal"></div>
        <div class="timer-progress">
          <div class="timer-progress-bar normal" style="width: 100%"></div>
        </div>
      </div>
    </div>
  </template>

  <!-- ШАБЛОН КАРТОЧКИ ПАЦИЕНТА (ДЕЙСТВИЯ ПРИОРИТЕТА) -->
  <template id="patient-action-card-template">
    <div class="patient-card action-mode" data-id="">
      <div class="card-top">
        <div class="patient-main">
          <h2 class="patient-name"></h2>
          <div class="patient-meta">
            <span class="performer"></span> • <span class="admission-time"></span>
          </div>
        </div>
        <div class="card-badges">
          <span class="priority-badge"></span>
          <span class="actions-progress-badge"></span>
        </div>
      </div>
      
      <!-- Два таймера рядом -->
      <div class="timers-row">
        <div class="timer-block actions-timer">
          <div class="timer-header">
            <i class="bi bi-stopwatch"></i> На действия
          </div>
          <div class="timer-display normal actions-time"></div>
          <div class="timer-progress">
            <div class="timer-progress-bar normal actions-bar" style="width: 100%"></div>
          </div>
        </div>
        
        <div class="timer-block brigade-timer hidden">
          <div class="timer-header brigade-label">
            <i class="bi bi-truck"></i> Прибытие
          </div>
          <div class="timer-display normal brigade-time"></div>
          <div class="timer-progress">
            <div class="timer-progress-bar normal brigade-bar" style="width: 100%"></div>
          </div>
        </div>
      </div>
    </div>
  </template>

  <script>
    // Конфигурация
    const CONFIG = {
      UPDATE_INTERVAL: 1000, // 1 секунда
      MAX_TIMER_WARNING: 60, // секунд до предупреждения
      MAX_TIMER_CRITICAL: 30, // секунд до критического
      EVENT_SOURCE_URL: '/monitor_events'
    };

    // Глобальные переменные
    let eventSource = null;
    let patientsData = {};
    let lastUpdateTime = null;

    // DOM элементы
    const elements = {
      patientsContainer: document.getElementById('patients-container'),
      noPatients: document.getElementById('no-patients'),
      patientsCount: document.getElementById('patients-count'),
      currentTime: document.getElementById('current-time'),
      template: document.getElementById('patient-card-template'),
      actionTemplate: document.getElementById('patient-action-card-template')
    };

    // Вспомогательные функции
    function formatTime(seconds) {
      if (!seconds && seconds !== 0) return '--:--';
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function getTimeClass(seconds) {
      if (seconds === undefined) return 'expired';
      if (seconds <= CONFIG.MAX_TIMER_CRITICAL) return 'critical';
      if (seconds <= CONFIG.MAX_TIMER_WARNING) return 'warning';
      return 'normal';
    }

    function getPriorityClass(priority) {
      const priorityMap = {
        'red': 'priority-1',
        'yellow': 'priority-2',
        'purple': 'priority-3',
        'green': 'priority-4',
        'pending': 'priority-pending'
      };
      return priorityMap[priority] || `priority-${priority}`;
    }

    function getPriorityText(priority) {
      const texts = {
        'red': '1 — Красный',
        'yellow': '2 — Желтый',
        'purple': '3 — Фиолетовый',
        'green': '4 — Зеленый',
        'pending': 'Определяется...'
      };
      return texts[priority] || priority;
    }

    function getStepText(step) {
      return `Этап ${step}`;
    }

    // Обновление времени
    function updateClock() {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('ru-RU');
      elements.currentTime.textContent = timeStr;
    }

    // Отрисовка карточки пациента
    function renderPatientCard(patient) {
      let card = elements.patientsContainer.querySelector(`[data-id="${patient.id}"]`);
      const isActionMode = patient.is_in_actions;
      
      // Проверяем, нужно ли пересоздать карточку (смена режима)
      if (card) {
        const wasActionMode = card.classList.contains('action-mode');
        if (wasActionMode !== isActionMode) {
          card.remove();
          card = null;
        }
      }
      
      if (!card) {
        // Выбираем нужный шаблон
        const template = isActionMode ? elements.actionTemplate : elements.template;
        card = template.content.cloneNode(true).querySelector('.patient-card');
        card.dataset.id = patient.id;
        elements.patientsContainer.appendChild(card);
        card = elements.patientsContainer.querySelector(`[data-id="${patient.id}"]`);
        
        // Плавное появление
        card.style.opacity = '0';
        setTimeout(() => {
          card.style.transition = 'opacity 0.3s ease';
          card.style.opacity = '1';
        }, 10);
      }
      
      // Обновляем класс приоритета
      const priorityClass = getPriorityClass(patient.priority);
      card.className = isActionMode 
        ? `patient-card action-mode ${priorityClass}` 
        : `patient-card ${priorityClass}`;
      
      // Заполняем общие данные (новая структура)
      card.querySelector('.patient-name').textContent = patient.full_name;
      card.querySelector('.performer').textContent = patient.performer_name || 'Не указан';
      card.querySelector('.admission-time').textContent = patient.admission_time || '—';
      
      if (isActionMode) {
        renderActionModeCard(card, patient, priorityClass);
      } else {
        renderTriageModeCard(card, patient, priorityClass);
      }
    }
    
    // Режим этапов триажа
    function renderTriageModeCard(card, patient, priorityClass) {
      const stepBadge = card.querySelector('.step-badge');
      stepBadge.textContent = getStepText(patient.step);
      stepBadge.className = `step-badge step-${patient.step}`;
      
      // Таймер этапа
      card.dataset.timerEndsAt = patient.timer_ends_at || 0;
      card.dataset.maxTime = patient.max_time || 120;
      card.dataset.mode = 'triage';
      
      updateTriageTimer(card, patient);
    }
    
    // Режим действий приоритета
    function renderActionModeCard(card, patient, priorityClass) {
      // Приоритет
      const priorityBadge = card.querySelector('.priority-badge');
      priorityBadge.textContent = getPriorityText(patient.priority);
      priorityBadge.className = `priority-badge ${priorityClass}`;
      
      // Прогресс действий
      const progressBadge = card.querySelector('.actions-progress-badge');
      if (progressBadge) {
        progressBadge.textContent = `${patient.actions_completed || 0}/${patient.actions_total || 0}`;
      }
      
      // Таймер на действия (5 минут)
      card.dataset.actionsEndsAt = patient.actions_timer_ends_at || 0;
      card.dataset.actionsMaxTime = patient.actions_max_time || 300;
      
      // Таймер бригады
      const brigadeBlock = card.querySelector('.brigade-timer');
      if (patient.brigade_timer_ends_at) {
        brigadeBlock.classList.remove('hidden');
        card.dataset.brigadeEndsAt = patient.brigade_timer_ends_at || 0;
        card.dataset.brigadeMaxTime = patient.brigade_max_time || 720;
        
        const brigadeLabel = card.querySelector('.brigade-label');
        if (brigadeLabel && patient.brigade_timer_label) {
          brigadeLabel.innerHTML = `<i class="bi bi-truck"></i> ${patient.brigade_timer_label}`;
        }
      } else {
        brigadeBlock.classList.add('hidden');
      }
      
      card.dataset.mode = 'actions';
      
      updateActionTimers(card, patient);
    }

    function updateTriageTimer(card, patient) {
      const now = Date.now() / 1000;
      let timeRemaining = patient.time_remaining || 0;
      if (patient.timer_ends_at) {
        timeRemaining = Math.max(0, Math.floor(patient.timer_ends_at - now));
      }
      
      const timerDisplay = card.querySelector('.timer-display');
      const timerBar = card.querySelector('.timer-progress-bar');
      
      if (!timerDisplay || !timerBar) return;
      
      const timeClass = getTimeClass(timeRemaining);
      timerDisplay.textContent = formatTime(timeRemaining);
      timerDisplay.className = `timer-display ${timeClass}`;
      timerBar.className = `timer-progress-bar ${timeClass}`;
      
      let percent = 100;
      if (patient.max_time && patient.max_time > 0) {
        percent = Math.max(0, (timeRemaining / patient.max_time) * 100);
      }
      timerBar.style.width = `${percent}%`;
    }
    
    function updateActionTimers(card, patient) {
      const now = Date.now() / 1000;
      
      // Таймер на действия
      const actionsEndsAt = parseFloat(card.dataset.actionsEndsAt) || 0;
      const actionsMaxTime = parseFloat(card.dataset.actionsMaxTime) || 300;
      const actionsRemaining = Math.max(0, Math.floor(actionsEndsAt - now));
      
      const actionsDisplay = card.querySelector('.actions-time');
      const actionsBar = card.querySelector('.actions-bar');
      
      if (actionsDisplay && actionsBar) {
        const actionsClass = getTimeClass(actionsRemaining);
        actionsDisplay.textContent = formatTime(actionsRemaining);
        actionsDisplay.className = `timer-display ${actionsClass} actions-time`;
        actionsBar.className = `timer-progress-bar ${actionsClass} actions-bar`;
        
        const actionsPercent = Math.max(0, (actionsRemaining / actionsMaxTime) * 100);
        actionsBar.style.width = `${actionsPercent}%`;
      }
      
      // Таймер бригады
      const brigadeEndsAt = parseFloat(card.dataset.brigadeEndsAt) || 0;
      if (brigadeEndsAt) {
        const brigadeMaxTime = parseFloat(card.dataset.brigadeMaxTime) || 720;
        const brigadeRemaining = Math.max(0, Math.floor(brigadeEndsAt - now));
        
        const brigadeDisplay = card.querySelector('.brigade-time');
        const brigadeBar = card.querySelector('.brigade-bar');
        
        if (brigadeDisplay && brigadeBar) {
          const brigadeClass = getTimeClass(brigadeRemaining);
          brigadeDisplay.textContent = formatTime(brigadeRemaining);
          brigadeDisplay.className = `timer-display ${brigadeClass} brigade-time`;
          brigadeBar.className = `timer-progress-bar ${brigadeClass} brigade-bar`;
          
          const brigadePercent = Math.max(0, (brigadeRemaining / brigadeMaxTime) * 100);
          brigadeBar.style.width = `${brigadePercent}%`;
        }
      }
    }

    // Обновление всех карточек
    function renderAllPatients(patients) {
      lastUpdateTime = new Date();
      
      // Обновляем счетчик
      elements.patientsCount.textContent = patients.length;
      
      if (patients.length === 0) {
        elements.noPatients.classList.remove('hidden');
        elements.patientsContainer.innerHTML = '';
        return;
      }
      
      elements.noPatients.classList.add('hidden');
      
      // Сохраняем текущие ID для удаления отсутствующих пациентов
      const currentIds = new Set(patients.map(p => p.id));
      const existingCards = elements.patientsContainer.querySelectorAll('.patient-card');
      
      // Удаляем карточки пациентов, которых больше нет
      existingCards.forEach(card => {
        const id = parseInt(card.dataset.id);
        if (!currentIds.has(id)) {
          card.remove();
        }
      });
      
      // Обновляем или создаем карточки
      patients.forEach(patient => {
        renderPatientCard(patient);
      });
      
      // Сортируем: сначала действия (action-mode), потом по приоритету
      const container = elements.patientsContainer;
      const cards = Array.from(container.querySelectorAll('.patient-card'));
      
      cards.sort((a, b) => {
        // Режим действий выше этапов триажа
        const aIsAction = a.classList.contains('action-mode') ? 0 : 1;
        const bIsAction = b.classList.contains('action-mode') ? 0 : 1;
        if (aIsAction !== bIsAction) return aIsAction - bIsAction;
        
        // Внутри группы сортируем по приоритету
        const getPriority = (card) => {
          if (card.className.includes('priority-1')) return 1;
          if (card.className.includes('priority-2')) return 2;
          if (card.className.includes('priority-3')) return 3;
          if (card.className.includes('priority-4')) return 4;
          return 5;
        };
        return getPriority(a) - getPriority(b);
      });
      
      // Переставляем карточки в правильном порядке
      cards.forEach(card => container.appendChild(card));
    }

    // Подключение к SSE
    function connectSSE() {
      try {
        if (eventSource) {
          eventSource.close();
        }
        
        eventSource = new EventSource(CONFIG.EVENT_SOURCE_URL);
        

        
        eventSource.onmessage = (event) => {
          try {
            const patients = JSON.parse(event.data);
            patientsData = patients.reduce((acc, p) => {
              acc[p.id] = p;
              return acc;
            }, {});
            
            // Добавляем максимальное время для этапов триажа (если не в режиме действий)
            const maxTimes = { 1: 120, 2: 300, 3: 600 };
            patients.forEach(p => {
              if (!p.is_in_actions) {
                p.max_time = p.max_time || maxTimes[p.step] || 120;
              }
            });
            
            renderAllPatients(patients);
          } catch (e) {
            console.error('Ошибка парсинга данных:', e);
          }
        };
        
        eventSource.onerror = () => {
          setTimeout(connectSSE, 5000); // Переподключение через 5 сек
        };
        
      } catch (e) {
        console.error('Ошибка SSE:', e);
        setTimeout(connectSSE, 10000);
      }
    }

    // Клиентский countdown таймеров (работает независимо от SSE)
    function updateTimers() {
      const now = Date.now() / 1000;
      const cards = elements.patientsContainer.querySelectorAll('.patient-card');
      
      cards.forEach(card => {
        const mode = card.dataset.mode;
        
        if (mode === 'actions') {
          // Режим действий приоритета
          updateActionTimersLocal(card, now);
        } else {
          // Режим этапов триажа
          updateTriageTimerLocal(card, now);
        }
      });
    }
    
    function updateTriageTimerLocal(card, now) {
      const timerDisplay = card.querySelector('.timer-display');
      const timerBar = card.querySelector('.timer-progress-bar');
      
      const timerEndsAt = parseFloat(card.dataset.timerEndsAt) || 0;
      const maxTime = parseFloat(card.dataset.maxTime) || 120;
      
      if (!timerEndsAt) return;
      
      const timeRemaining = Math.max(0, Math.floor(timerEndsAt - now));
      
      const timeClass = getTimeClass(timeRemaining);
      timerDisplay.textContent = formatTime(timeRemaining);
      timerDisplay.className = `timer-display ${timeClass}`;
      timerBar.className = `timer-progress-bar ${timeClass}`;
      
      const percent = Math.max(0, (timeRemaining / maxTime) * 100);
      timerBar.style.width = `${percent}%`;
    }
    
    function updateActionTimersLocal(card, now) {
      // Таймер на действия
      const actionsEndsAt = parseFloat(card.dataset.actionsEndsAt) || 0;
      const actionsMaxTime = parseFloat(card.dataset.actionsMaxTime) || 300;
      
      if (actionsEndsAt) {
        const actionsRemaining = Math.max(0, Math.floor(actionsEndsAt - now));
        
        const actionsDisplay = card.querySelector('.actions-time');
        const actionsBar = card.querySelector('.actions-bar');
        
        if (actionsDisplay && actionsBar) {
          const actionsClass = getTimeClass(actionsRemaining);
          actionsDisplay.textContent = formatTime(actionsRemaining);
          actionsDisplay.className = `timer-display ${actionsClass} actions-time`;
          actionsBar.className = `timer-progress-bar ${actionsClass} actions-bar`;
          
          const actionsPercent = Math.max(0, (actionsRemaining / actionsMaxTime) * 100);
          actionsBar.style.width = `${actionsPercent}%`;
        }
      }
      
      // Таймер бригады
      const brigadeEndsAt = parseFloat(card.dataset.brigadeEndsAt) || 0;
      if (brigadeEndsAt) {
        const brigadeMaxTime = parseFloat(card.dataset.brigadeMaxTime) || 720;
        const brigadeRemaining = Math.max(0, Math.floor(brigadeEndsAt - now));
        
        const brigadeDisplay = card.querySelector('.brigade-time');
        const brigadeBar = card.querySelector('.brigade-bar');
        
        if (brigadeDisplay && brigadeBar) {
          const brigadeClass = getTimeClass(brigadeRemaining);
          brigadeDisplay.textContent = formatTime(brigadeRemaining);
          brigadeDisplay.className = `timer-display ${brigadeClass} brigade-time`;
          brigadeBar.className = `timer-progress-bar ${brigadeClass} brigade-bar`;
          
          const brigadePercent = Math.max(0, (brigadeRemaining / brigadeMaxTime) * 100);
          brigadeBar.style.width = `${brigadePercent}%`;
        }
      }
    }

    // Инициализация
    document.addEventListener('DOMContentLoaded', () => {
      // Обновляем часы каждую секунду
      updateClock();
      setInterval(updateClock, 1000);
      
      // Обновляем таймеры каждую секунду
      setInterval(updateTimers, 1000);
      
      // Подключаемся к SSE
      connectSSE();
      
      // Фокус на окне для предотвращения сна экрана
      window.addEventListener('focus', () => {
        if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
          connectSSE();
        }
      });
      
      // Обработка видимости страницы
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && (!eventSource || eventSource.readyState === EventSource.CLOSED)) {
          connectSSE();
        }
      });
    });

    // Автоматическое обновление при потере соединения
    window.addEventListener('online', () => {
      if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
        connectSSE();
      }
    });
  </script>
</body>
</html>